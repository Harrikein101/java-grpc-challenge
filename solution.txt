Разработан gRpc сервис.
Были сделаны все задания,
также было добавлено несколько тестов, в том числе на округление малых величин и на ошибки (1. несуществующая валюта, 2. невозможно определить цену конвертации).

Для хранения коэффициентов конвертации валют я использовал ориентированный взвешенный граф (реализован класс DirectedWeightedGraph).
Вершины графа - это валюты.
Вес направленного ребра AB - это коэффициент конвертации из валюты A в валюту B.
"Длина пути" в графе - это перемножение весов рёбер, входящих в путь.

Чтобы сконвертировать из одной валюты в другую, я перемножаю количество денег на длину пути в графе для этих двух валют.

Возможно несколько подходов к поиску пути в графе - в зависимости от того, как часто будут происходить операции конвертации и операции добавления новых коэффициентов валют.
Я исходил из предположения, что новые коэффициенты валют будут меняться намного реже, чем происходить операции конвертации. Поэтому я заранее просчитываю все пути в графе после каждого добавления ребра и сохраняю эти пути в память - этот подход реализован в классе DirectedWeightedGraphWithPreprocessing (я использую простой динамический алгоритм со сложностью O(V*V), но существует алгоритм со сложностью O(V + E) - это про дальнейшие оптимизации). Поэтому операция добавления новых коэффициентов у меня происходит медленно (и притом syncronized), а операция конвертации - очень быстро.

Алгоритм всегда считает наиболее выгодную длину пути (то есть где коэффициент конвертации больше).

Если операции конвертации происходят намного реже, чем изменения цены, то тогда мне следовало использовать другую реализацию ориентированного графа - без подсчётов всех путей заранее, а считать путь именно при запросе конвертации (также можно сохранять в кэш посчитанные коэффициенты, чтобы не считать один и тот же путь дважды - а при добавлении ребра кэши сбрасывать).

Дальнейшие оптимизации: 1) сделать скорость алгоритма O(V + E)  2) многопоточность (проверить нет ли лишних блокировок, можно с профайлером посидеть)  3) работа с BigDecimal (например, проверить эффективно ли я память расходую при работе с BigDecimal)
